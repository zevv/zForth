( system calls )

: emit ( n -- ) 0 sys ;
: . ( n -- ) 1 sys ;
: tell ( addr len -- ) 2 sys ;
: quit ( -- ) 128 sys ;
: sin ( n -- n' ) 129 sys ;
: include ( addr len -- ) 130 sys ;
: save ( -- ) 131 sys ;


( dictionary access for regular variable-length cells. These are shortcuts
  through the primitive operations are !!, @@ and ,, )

: ! ( val addr -- ) 0 !! ;
: @ ( addr -- val ) 0 @@ ;
: , ( val -- ) 0 ,, ;
: # ( n -- ) 0 ## ;

( dictionary access for jmp instructions; these make sure to always use the
  maximium cell size for the target address to allow safe stubbing and
  updating of a jump address. `64` is the magic number for ZF_ACCESS_VAR_MAX,
  see zforth.c for details )

: !j ( val addr -- ) 64 !! ;
: ,j ( val -- ) 64 ,, ;

( compiler state )

: [ ( -- ) 0 compiling ! ; immediate
: ] ( -- ) 1 compiling ! ;
: postpone ( -- ) 1 _postpone ! ; immediate


( some operators and shortcuts )
: 1+ ( n -- n+1 ) 1 + ;
: 1- ( n -- n-1 ) 1 - ;
: over ( n1 n2 -- n1 n2 n1 ) 1 pick ;
: +! ( val addr -- ) dup @ rot + swap ! ;
: inc ( addr -- ) 1 swap +! ;
: dec ( addr -- ) -1 swap +! ;
: < ( n1 n2 -- flag ) - <0 ;
: > ( n1 n2 -- flag ) swap < ;
: <= ( n1 n2 -- flag ) over over >r >r < r> r> = + ;
: >= ( n1 n2 -- flag ) swap <= ;
: =0 ( n -- flag ) 0 = ;
: not ( flag -- not_flag ) =0 ;
: != ( n1 n2 -- flag ) = not ;
: cr ( -- ) 10 emit ;
: br ( -- ) 32 emit ;
: .. ( n -- n ) dup . ;
: here ( -- addr ) h @ ;


( memory management )

: allot ( n -- ) h +!  ;
: var ( -- ) : ' lit , here 5 allot here swap ! 5 allot postpone ; ; ( defining word; created word: <name> ( -- addr ) )
: const ( val -- ) : ' lit , , postpone ; ; ( defining word; created word: <name> ( -- val ) )
: constant ( val -- ) >r : r> postpone literal postpone ; ; ( defining word; created word: <name> ( -- val ) )
: variable ( -- ) >r here r> postpone , constant ; ( defining word; created word: <name> ( -- addr ) )

( 'begin' gets the current address, a jump or conditional jump back is generated
  by 'again', 'until' )

: begin ( -- addr ) here ; immediate
: again ( addr -- ) ' jmp , , ; immediate
: until ( addr -- ) ' jmp0 , , ; immediate


( '{ ... ... ... n x}' repeat n times definition - eg. : 5hello { ." hello " 5 x} ; )

: { ( -- loop_start_addr ) ' lit , 0 , ' >r , here ; immediate
: x} ( loop_start_addr -- ) ' r> , ' 1+ , ' dup , ' >r , ' = , postpone until ' r> , ' drop , ; immediate


( vectored execution - execute XT eg. ' hello exe )

: exe ( xt -- ) ' lit , here dup , ' >r , ' >r , ' exit , here swap ! ; immediate

( execute XT n times  e.g. ' hello 3 times )
: times ( xt count -- ) { >r dup >r exe r> r> dup x} drop drop ;


( 'if' prepares conditional jump, the target address '0' will later be
  overwritten by the 'else' or 'fi' words. Note that ,j and !j are used for
  writing the jump target address to the dictionary, this makes sure that the
  target address is always written with the same cell size)

: if ( -- addr_if_target_loc ) ' jmp0 , here 0 ,j ; immediate ( runtime: flag -- )
: unless ( -- addr_if_target_loc ) ' not , postpone if ; immediate ( runtime: flag -- )
: else ( addr_if_target_loc -- addr_else_target_loc ) ' jmp , here 0 ,j swap here swap !j ; immediate
: fi ( addr_target_loc -- ) here swap !j ; immediate


( forth style 'do' and 'loop', including loop iterators 'i' and 'j' )

: i ( -- ) ' lit , 0 , ' pickr , ; immediate ( compiled code: -- index )
: j ( -- ) ' lit , 2 , ' pickr , ; immediate ( compiled code: -- outer_loop_index )
: do ( -- loop_start_addr ) ' swap , ' >r , ' >r , here ; immediate ( runtime: limit start -- ; R: index limit )
: loop+ ( loop_start_addr -- ) ' r> , ' + , ' dup , ' >r , ' lit , 1 , ' pickr , ' >= , ' jmp0 , , ' r> , ' drop , ' r> , ' drop , ; immediate ( runtime: step -- ; R: index limit (initially) -- (finally) )
: loop ( loop_start_addr -- ) ' lit , 1 , postpone loop+ ;  immediate ( runtime: -- ; R: index limit (initially) -- (finally) )


( Create string literal, puts length and address on the stack )

: s" ( -- addr len ) compiling @ if ' lits , here 0 , fi here begin key dup 34 = if drop
     compiling @ if here swap - swap ! else dup here swap - fi exit else , fi
     again ; immediate

( Print string literal )

: ." ( -- ) compiling @ if postpone s" ' tell , else begin key dup 34 = if drop exit else emit fi again
     fi ; immediate

(
vi: ts=3 sw=3 ft=forth
)
